---
title: Composability of programs or contracts
author: shivam
moduleNumber: module-3
modulePart: module-3-a
thisFileName: composability
orderNumber: '1'
modulePartDescription: In this part of the module, you will explore the composability of programs and how it works in Solana and Ethereum. You will also learn how to implement Cross-Program Invocation techniques.
---

# Objectives

In this lesson, you will:

- Understand the concept of composability in web3
- Understand the differences between Solana and Ethereum in terms of composability.
- Explore composability of programs in Solana via CPI and PDA

## tl;dr

Composability in Web3 is similar to how open-source software components are used to build various applications. In Solana, composability is akin to Functional Programming (FP), while Ethereum's approach is closer to Interface-based Inheritance (OOP). Solana uses spl-token to manage tokens centrally, while Ethereum has separate contracts like ERC-20.

It enables blockchain apps to collaborate by linking together through smart contracts or project assembly. Composability offers quicker development, enhanced innovation, and user-friendly collaboration in the Web3 ecosystem.

# Overview

Composability is a concept that might be familiar to Web2 developers. It means using software parts that fit into various apps. This concept has existed since the advent of open-source technology and held significant importance during the early days of the Internet. While web2 got a boost from this, web3 also relies on it improve user experiences and spark fresh ideas.

Web3, the updated Internet version, is reintroducing composability. In Web3, composability occurs when parts of blockchain apps link up, either via smart contracts or project assembly. It allows various blockchain apps, such as trading platforms and decentralized apps, to collaborate.

## Composability Of Programs (within Solana and Ethereum)

In Solana, composability can be considered to be like Functional Programming (FP). It is similar to having separate roles for a smart contract and the data it uses. When dealing with Solana, transactions is centered around Solana accounts, which form the core of the entire Solana ecosystem. Unlike Ethereum, where each token has its special contract, Solana uses something called **spl-token** to control all tokens in one place.

Ethereum's composability is akin to interface-based inheritance in traditional Object Oriented Programming (OOP). This means that if something acts like a particular entity, it's treated as such. In Ethereum, you expand on established standards like ERC-20 and implement the necessary functions.

On Ethereum, data lives right inside the smart contract. But in Solana, data is spread out across many atomic accounts. Even though it might sound a bit complex, this setup lets Solana do many things at the same time. Transactions that need to look at an account, without changing it, can all happen together.

In Solana's programming universe, different programs can talk to each other using something called cross-program invocation and PDA. One program can tell another program what to do. The starting program takes a little break while the other program does its thing.

Here's a simplified comparison table between Solana and Ethereum composability:

| Aspect | Solana | Ethereum |
| --- | --- | --- |
| Composability Approach | Like Functional Programming (FP) | Interface-based Inheritance (OOP) |
| Token Management | Centralised through spl-token | Each token has its own contract (e.g., ERC-20) |
| Transaction Foundation | Centered around Solana accounts | Focuses on smart contract interaction |
| Data Storage | Data distributed across atomic accounts | Data stored within the smart contract |
| Concurrency Advantage | Supports simultaneous task execution | Limited parallel processing |
| Inter-program Comm. | Cross-program invocation and PDA | Interface and inheritance |

### Composability of programs in Solana via CPI and PDA

Cross-Program Invocation (CPI) is key to ensuring collaboration between Solana programs. This enables the composability of Solana programs. It enables one program to call another, establishing a smooth connection. This feature simplifies the expansive Solana system into a unified ecosystem for developers.

**Calling Programs with CPIs**

A Cross-Program Invocation (CPI) is when one program calls another program, aiming at a certain instruction in that program. CPIs allow the calling program to extend its signer privileges to the callee program.

This is achieved using instructions like invoke or invoke_signed. The latter is employed when programs have to give their signatures for Program-Derived Addresses (PDAs, which we'll cover in this series).

CPIs are what make Solana programs work together. Any public instruction of a program can be triggered by another program using a CPI. This makes different programs within the Solana system work together like clockwork. Even though we can't control the accounts and data that are sent to a program, we should always double-check the information we pass into a CPI. This is crucial for keeping the program secure and working as expected.

Don't worry if the concept of one program calling another seems complex – it's quite straightforward. Think of it as giving directions using an "Instruction."

To make a CPI, you must specify and construct an instruction on the program being invoked and supply a list of accounts necessary for that instruction. If a PDA is required as a signer, the `signers_seeds` must also be provided when using `invoke_signed`.

To make this work, the Instruction needs three things: the program ID of the program you're calling, information(data) that the program can understand, and a list of "AccountInfos." These AccountInfos are like the accounts the program you're calling will use see diagram below.

!https://res.cloudinary.com/practicaldev/image/fetch/s--xvVbwsNQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m4wk78dpsrkw485afpks.jpeg

Here's the neat part: the calling program receives these AccountInfos from the system at the beginning. This means that any account the program you're calling requires must also be needed by the calling program. It's like a chain reaction – one thing leads to another.

Oh, and that program ID we mentioned? The program doing the calling needs to get it in the same way. It's a rule everyone follows.

Imagine this instruction as a recipe – you gather these elements, and then something incredible unfolds. It's like a sort of magic that's built into the Solana system.

***In this tutorial, you'll discover how to use invoke CPI in Solang when a program-derived address (PDA) isn't required for the signer.***

### Composability of contracts in Ethereum

Smart contracts on Ethereum work like public APIs – they're like building blocks that can be used without starting from scratch. For instance, you can use the ready-made smart contracts from projects like Uniswap, a decentralized exchange, to simplify tasks in your app.

**How Composability Works in Ethereum**

Ethereum's smart contracts are open to everyone, enhancing app development. Composability relies on three aspects:

1. **Modularity:** Each smart contract has a specific role.
2. **Autonomy:** Smart contracts can function .
3. **Discoverability:** Anyone can use and modify smart contracts.

An Example:

Imagine a situation where a token has a higher value on one exchange than another. If you have enough money, you can buy it on the cheaper exchange and sell it on the more expensive one to make a profit. But if you don't have enough money, you can use something called a flash loan. This kind of loan lets you borrow assets without having to put up anything as security. With flash loans, you can do complicated things in one move, like buying and selling tokens to make money. And all this is possible because smart contracts are working together.

Advantages of Composability:

- **Quicker Development:** Developers avoid starting from scratch.
- **Enhanced Innovation:** Experimenting with new ideas becomes simpler.
- **User-Friendly:** Apps collaborate seamlessly.

In the next lesson, we write the code for our CPI Flip program.